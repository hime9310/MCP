指定された **Terraform MCP Server** 製品（v7liwliuew3f4）をベースに、Port 80（In）/ Port 443（Out）の制約を反映した一式を作成しました。

---

### 1. 製品仕様のまとめと構成上の注意点

この製品は、Terraform Registryとの連携やIaC開発をAI（Kiro）で自動化するためのMCPサーバです。

* **仕様リンク**: [AWS Marketplace: Terraform MCP Server](https://aws.amazon.com/marketplace/pp/prodview-v7liwliuew3f4)
* **技術スタック**:
* **通信プロトコル**: SSE (Server-Sent Events)。
* **ポート設定**: デフォルトは `8080` ですが、環境変数 `TRANSPORT_PORT` で変更可能です。
* **エンドポイント**: デフォルトパスは `/mcp` です。


* **今回の構成に関連する重要事項**:
* **Port 80への強制**: 環境変数 `TRANSPORT_PORT=80` を指定し、内部リッスンを80に変更します。
* **外部通信 (443)**: Terraform Registry API 等への接続に HTTPS(443) を利用するため、アウトバウンド制限下でも動作可能です。
* **環境変数**: `TRANSPORT_MODE=streamable-http` への設定変更が必須です（デフォルトは stdio のため）。



---

### 2. 既存モジュールの修正案 (Fargate/main.tf)

既存モジュールを今回の制約に適合させるために、以下の修正を行います。

```hcl
# Fargate/main.tf

# 修正箇所①：自己参照エラーの解消
resource "aws_ecs_task_definition" "this" {
  # [修正理由] 既存の depends_on = [aws_ecs_task_definition.this] は循環参照エラーとなるため削除。
}

# 修正箇所②：アウトバウンドを443(HTTPS)に固定
resource "aws_security_group_rule" "ecs_egress" {
  type              = "egress"
  from_port         = 443   # [修正] 0 -> 443
  to_port           = 443   # [修正] 0 -> 443
  protocol          = "tcp" # [修正] -1 -> tcp
  security_group_id = aws_security_group.this.id
  cidr_blocks       = ["0.0.0.0/0"]
  description       = "Allow only HTTPS outbound for Registry API"
  # [修正理由] 決定事項に基づき、外部API（443）以外の不要な通信を遮断します。
}

# 修正箇所③：変数名のタイポ修正
resource "aws_security_group_rule" "ecs_ingress_alb" {
  # ... (略)
  # [修正] source_security_group_id = var.lb_security_group_id
  # [修正理由] 既存コードで var. が抜けていたため修正します。
}

```

---

### 3. ルートモジュール一式 (dev環境)

#### `main.tf`

Port 80でのリッスンと、製品固有の環境変数を定義します。

```hcl
module "terraform_mcp" {
  source = "./Fargate"

  name_prefix = "tf-mcp"
  env         = "dev"
  name_suffix = "01"

  # コンテナ設定 (Port 80強制)
  container_image_name_or_uri = var.image_uri
  container_port              = 80
  host_port                   = 80
  
  # 製品仕様に基づく環境変数
  container_command = [
    "TRANSPORT_MODE=streamable-http",
    "TRANSPORT_PORT=80",
    "TRANSPORT_HOST=0.0.0.0",
    "MCP_ENDPOINT=/mcp"
  ]

  vpc_id             = var.vpc_id
  ecs_subnet_id_list = var.subnet_ids
  ecs_log_group      = "/aws/ecs/tf-mcp-dev"
  auto_scaling_enabled = false
}

# Local PCからのPort 80許可
resource "aws_security_group_rule" "ingress_local" {
  type              = "ingress"
  from_port         = 80
  to_port           = 80
  protocol          = "tcp"
  security_group_id = module.terraform_mcp.security_group_id_ecs
  cidr_blocks       = var.allowed_cidr
}

```

#### `terraform.tfvars`

```hcl
image_uri    = "709825985650.dkr.ecr.us-east-1.amazonaws.com/amazon/terraform-mcp-server:latest"
vpc_id       = "XXXXXXXX"
subnet_ids   = ["XXXXXXXX", "XXXXXXXX"]
allowed_cidr = ["XXXXXXXX"] # 社内NW帯域

```

---

### 4. 基本設計書（抜粋）

* **インバウンド設計**: ポート 80 (TCP)。Local PC から Fargate タスクへ直接アクセス。
* **アウトバウンド設計**: ポート 443 (TCP)。Terraform Registry API 等への HTTPS 通信専用。
* **コンピューティング**: ECS Fargate。OS管理不要なサーバーレス構成。
* **可用性**: PoCのため1タスク構成。IP変動は手動更新にて許容。

---

### 5. テスト仕様書

1. **疎通テスト**: `curl -v http://[Task_IP]:80/mcp` を実行し、接続が確立されるか。
2. **セキュリティテスト**: ポート 8080 や 8000 でのアクセスが拒否されるか。
3. **機能テスト**: Kiro 上で Terraform のモジュール検索機能が動作するか。

---

### 6. Kiroとの連携設定（デスクトップ版）

Kiro IDE の MCP 設定画面で以下を登録します。

* **Type**: `SSE`
* **URL**: `http://[FargateタスクのプライベートIP]:80/mcp`
* ※製品仕様により `/mcp` がエンドポイントとなります。



IPが変わった際は、このURLのIP部分のみを書き換えて保存してください。

結論から申し上げますと、**Port 80で全く問題ありません**。

公式ドキュメントやMarketplaceの指示にある「8080（または8000）」はあくまで**デフォルト値**です。Terraform MCP Serverを含む多くのMarketplace製品は、環境変数 `TRANSPORT_PORT` を指定することで、コンテナが待ち受けるポートを自由に変更できるよう設計されています。

今回の「社内NWから80しか通らない」という制約に対し、以下の設定を行うことで80番ポートでの運用が正攻法として成立します。

---

### 1. Terraform MCP Server (v7liwliuew3f4) 仕様まとめ

HashiCorp公式のこのMCPサーバは、AIがTerraform Registryの最新情報を参照したり、ワークスペース操作を行うための架け橋となります。

* **仕様の重要ポイント**:
* **デプロイ形式**: Linuxベースのコンテナイメージ。
* **通信方式**: SSE (Server-Sent Events) をサポートしており、リモート接続に最適。
* **エンドポイント**: デフォルトパスは `/mcp` です。


* **要注意事項（今回の構成に関連）**:
* **環境変数によるポート変更**: `TRANSPORT_PORT=80` を指定することで、コンテナ内部のプロセス自体が80番で起動します。これにより、Fargateの `container_port` と一致させることができます。
* **トランスポートモード**: デフォルトは `stdio`（ローカル実行用）のため、必ず `TRANSPORT_MODE=streamable-http` を設定する必要があります。



---

### 2. 既存モジュールの修正 (Fargate/main.tf)

PoCの決定事項（In:80 / Out:443）と循環参照エラーの回避を反映します。

```hcl
# Fargate/main.tf の修正内容

# ① 循環参照の削除
resource "aws_ecs_task_definition" "this" {
  # [修正] depends_on = [aws_ecs_task_definition.this] を削除
  # 理由: Terraformで自分自身に依存する設定はエラーになるため。
}

# ② アウトバウンドを443(HTTPS)に固定
resource "aws_security_group_rule" "ecs_egress" {
  type              = "egress"
  from_port         = 443   # [修正] 0 -> 443
  to_port           = 443   # [修正] 0 -> 443
  protocol          = "tcp" # [修正] -1 -> tcp
  security_group_id = aws_security_group.this.id
  cidr_blocks       = ["0.0.0.0/0"]
  description       = "Allow HTTPS only (Registry API access)"
  # 理由: 決定事項に基づき、Registry API等へのセキュアな通信のみを許可するため。
}

# ③ セキュリティグループの変数名タイポ修正
resource "aws_security_group_rule" "ecs_ingress_alb" {
  # ... 略
  source_security_group_id = var.lb_security_group_id # [修正] var. を追加
  # 理由: 提供されたコードでは var. が抜けており、未定義エラーになるため。
}

```

---

### 3. ルートモジュール一式

`Fargate` フォルダと同じ階層に配置します。

#### `main.tf`

```hcl
module "tf_mcp_server" {
  source = "./Fargate"

  name_prefix = "tf-mcp"
  env         = "dev"
  name_suffix = "01"

  # Port 80 を強制指定
  container_image_name_or_uri = var.image_uri
  container_port              = 80
  host_port                   = 80

  # 製品仕様に基づく環境変数設定
  container_command = [
    "TRANSPORT_MODE=streamable-http",
    "TRANSPORT_PORT=80",
    "TRANSPORT_HOST=0.0.0.0",
    "MCP_ENDPOINT=/mcp"
  ]

  vpc_id             = var.vpc_id
  ecs_subnet_id_list = var.subnet_ids
  ecs_log_group      = "/aws/ecs/tf-mcp-dev"
  auto_scaling_enabled = false
}

# 社内NWからのPort 80許可
resource "aws_security_group_rule" "ingress_from_local" {
  type              = "ingress"
  from_port         = 80
  to_port           = 80
  protocol          = "tcp"
  security_group_id = module.tf_mcp_server.security_group_id_ecs
  cidr_blocks       = var.allowed_cidr_list
}

```

#### `terraform.tfvars`

```hcl
image_uri         = "709825985650.dkr.ecr.us-east-1.amazonaws.com/amazon/terraform-mcp-server:latest"
vpc_id            = "XXXXXXXX"
subnet_ids        = ["XXXXXXXX", "XXXXXXXX"]
allowed_cidr_list = ["XXXXXXXX"] # Local PCの属する帯域

```

---

### 4. 基本設計書（抜粋）

* **通信要件**: インバウンド Port 80 (Local PC → ECS)。アウトバウンド Port 443 (ECS → Terraform Registry)。
* **構成**: AWS ECS Fargate 1タスク構成。
* **認証**: Terraform Cloud連携時は環境変数 `TFE_TOKEN` を追加で渡す設計とする。

---

### 5. テスト仕様書

1. **疎通**: Local PCから `curl -I http://[タスクIP]:80/mcp` が成功すること。
2. **遮断**: Port 8080 等、許可外のポートでアクセスがタイムアウトすること。
3. **連携**: Kiro IDE上で接続ステータスが「Active」になること。

---

### 6. Kiroとの連携設定（デスクトップ版）

Kiro IDE の設定画面で以下を入力してください。

* **Server Name**: `Terraform-MCP`
* **Type**: `SSE`
* **URL**: `http://[FargateタスクのプライベートIP]:80/mcp`

この構成により、8080番に頼ることなく、社内NWの制約（Port 80）を遵守したまま運用が可能です。

**もし、Terraform Cloudのトークン（TFE_TOKEN）など、機密情報の渡し方についてさらに詳細な設計が必要であれば、続けてお手伝いしましょうか？**

まとめ：Tokenが「どこで」使われるか
Kiro が MCPサーバ（Fargate）に質問する。

MCPサーバ が Terraform Cloud に「情報をください」とリクエストを送る。

この時、MCPサーバはリクエストに Terraform APIトークン を載せて送ります。

Terraform Cloudがトークンを確認し、正しい権限であれば情報を返します。

ーーー
トークンの設定は今回のインフラ構築作業そのもののためではなく、**「構築した後の運用（利用者がKiroを使って作業する時）」**のために必要になります。

混乱を招かないよう、時間軸で整理します。

1. 今回の構築フェーズ（あなたが今やっていること）
作業内容: Terraformを使って、AWS上にECS Fargate（MCPサーバ）を立てる。

必要な鍵: あなたの**AWS操作権限（IAM等）**のみ。

トークンの扱い: この段階では、将来の利用者が使うための「器（環境変数）」を定義しておくだけです。

2. 運用フェーズ（構築完了後、Kiro利用者が使う時）
作業内容: 利用者がKiroに「今のインフラ構成を見せて」「新しいS3バケットを作成して」と指示を出す。

必要な鍵: Terraform APIトークン。

なぜ必要か:

Kiro利用者の指示を受けたMCPサーバが、最新の構成図や設定値（tfstate）を取得するために、Terraform Cloud（情報の保管場所）へアクセスする必要があるからです。

このトークンがないと、MCPサーバは「誰だか分からない人からのアクセス」として拒絶され、Kiroはインフラ情報を読み取ることができません。

まとめ
トークンは、**「Kiro利用者がTerraformをAIで操作できるようにするためのログインパスワード」**のようなものです。

システム構築者であるあなたは、利用者がKiroを使い始めた時に「ログインできない！」とならないよう、あらかじめMCPサーバの中にこのトークンを仕込んで（設定して）おいてあげる、という役割になります。

もし、今回のPoCをあなた一人で完結させ、かつTerraform Cloud等を使わずにローカルのファイルだけで完結させるのであれば、このトークンの設定は後回しにしても、構築自体には支障ありません。